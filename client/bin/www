#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('app:server');
var http = require('http');
const socketio = require('socket.io');
const chalk = require('chalk');
const axios = require('axios');

const users = [];

// Join user to chat
function userJoin(id, to, from, matchedUsername, username, convId) {
  const user = { id, to, from, matchedUsername, username, convId };

  users.push(user);

  return user;
}

// Get current user
function getCurrentUser(id) {
  return users.find(user => user.id === id);
}

// Get current user
function checkConnectedUser(id, id2, convId) {
  for (const user of users) {
    if (user.from === id && user.to === id2 && user.convId === convId) {
      return true
    }
  }
  return false
}

// User leaves chat
function userLeave(id) {
  const index = users.findIndex(user => user.id === id);

  if (index !== -1) {
    return users.splice(index, 1)[0];
  }
}

function formatMessage(username, msg) {
  return {
    username,
    msg,
    //time: moment().format('h:mm a')
  };
}

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '8080');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);
const io = socketio(server);
// const sendMsgRouter = require('../routes/sendMsg')(io);

// app.use('/sendMsg', sendMsgRouter);


io.on('connection', socket => {
  // socket.emit('message', 'user connected');
  socket.on('joinConv', ({ to, from, matchedUsername, username, convId }) => {
    // const user = {socket:socket.id, userFrom, convId};
    const user = userJoin(socket.id, to, from, matchedUsername, username, convId);
    console.log(chalk.red(JSON.stringify(users)))
    socket.join(user.convId);

    // // Welcome current user
    // socket.emit('message', formatMessage('botName', `welcome`));

    // // Broadcast when a user connects
    // socket.broadcast
    //   .to(user.convId)
    //   .emit(
    //     'message',formatMessage('botName', `${user.username} has joined the chat`));

    // Send users and room info
    // io.to(user.room).emit('roomUsers', {
    //   room: user.room,
    //   users: getRoomUsers(user.room)
    // });
  });
  // Listen for chatMessage
  socket.on('chatMessage', msg => {
    const user = getCurrentUser(socket.id);
    console.log('current user ' + JSON.stringify(user))
    let isRead = 0;
    if (checkConnectedUser(user.to, user.from, user.convId))
      isRead = 1;

    // to, from, matchedUsername, username, convId
    let sendMsg = {userTo: user.to, userFrom: user.from, convId: user.convId, msg, isRead}
    // console.log(chalk.blue(JSON.stringify(sendMsg)))
    
    axios.post(`${process.env.HostApi}/sendMsg`, sendMsg)
    .then((respo) => {
        io.to(user.convId).emit('message', formatMessage(user.username, msg));
        console.log(chalk.green(respo.data.successMessage))
    }).catch((e) => {
      console.log(chalk.red( e.response.data.errorMessage.error))
      socket.error(e.response.data.errorMessage.error)
    })

    // io.to(user.to).emit('unreadMsgs', () => {
              
    //         })

    // socket.emit('error', error);
    // .catch((e) => {
    //   //handle.authError(e, req, res);
    //   if(typeof e.response !== 'undefined') {
    //     if(e.response.status === 400) {
    //       console.log(chalk.red( e.response.data.errorMessage.error))
    //       // socket.emit('error', e.response.data.errorMessage.error);
    //       // req.flash('error', e.response.data.errorMessage.error);
    //       // res.redirect('/');
    //     }
    //   }    
    // })
    //io.to(user.convId).emit('message', msg);
  });

  // Runs when client disconnects
  socket.on('disconnect', () => {
    console.log('disconnect')
    console.log(socket.id)
    const user = userLeave(socket.id);

    // if (user) {
    //   io.to(user.room).emit(
    //     'message',
    //     formatMessage(botName, `${user.username} has left the chat`)
    //   );

    //   // Send users and room info
    //   io.to(user.room).emit('roomUsers', {
    //     room: user.room,
    //     users: getRoomUsers(user.room)
    //   });
    // }
  });
})
/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
